روی یک تیم هستیم و الگوی میکروسرویس داریم استفاده میکنیم


به طور کلی، در معماری microservice دو راه برای برقرای ارتباط بین سرویس ها وجود دارد:

    ارتباط Synchronous (همزمان): در این نوع ارتباط، یک برنامه یا سرویس به طور مستقیم و با استفاده از پروتکل HTTP با برنامه دیگر ارتباط برقرار می کند که نیاز به پاسخ فوری و مستقیم از سرور دارد.

    ارتباط Asynchronous (غیرهمزمان): در این نوع ارتباط که از مکانیزم publish-subscribe استفاده می شود، نیازی به پاسخ فوری از سرور نیست و پیام ها (درخواست ها) به یک کارگزار پیام (مانند RabbitMQ) ارسال می شوند و سرویس مربوطه آن را گرفته و پردازش می کند.


--------------------------------------------------------------------------------------------------
مسیج بروکر ها یا کارگزار پیام نرم افزاری که برنامه و سیستم ها و سرویس ها رو قادر میسازد تا با یکدیگر ارتباط برقرار کرده و تبادل اطلاعات نمایید
مسیج بروکر ها با ترجمه پیام به پروتکل های پیام رسانی رسمی این کار رو انجام میدهند
به سرویس ها وابسته این امکان رو میدهد تا با یکدیگر صحبت کنند
پیام ها توسط یک تولید کننده به producer تولید میشوند
یک پیام که تولید میشود و در صف قرار میگیرد به این فرایند Enqueuing نام دارد
پیام هایی که ارسال میشود(push) در یک صف باقی میماند و منتظر میماند که یک consumer ان را پردازش کند که به این فرایند Dequeuing معروف هست
و این امکان رو داریم که یک پیام را در انتظار دریافت یک consumer در یک صف پیام قرار دهیم
بنابراین فرایند (push) شدن یک پیام و قرار گرفتن در یک صف(queue) توسط producer و مصرف شدن ان توسط consumer را که عنوان Message queueing (صف بندی پیام) شناخته میشود


--------------------------------------------------------------------------------------------------
پروتکل های rabbitmq
amqp
stomp
mqtt
http

AMQPپروتکل اصلی هست که توسط این بروکر پشتیبانی میشود
advance Message queueing protocol
stompیک پروتکل پیام رسانی ساده هست
mqttیک پروتکل باینری هست که به دلیل ارسال پیام سبک معروف هست





-------------------------------------------------------------------------------------------------

جریان پیام در RabbitMQ
پیام ها مستقیما به صف ارسال نمیشود ودر ابتدا توسط exchange دریافت میشود این exchange ها بسته به قوانین که تعیین شده هست چهار نوع مختلف وجود دارد
به طور کی این exchange ها پیام ها رو درون صف ها پخش میکنند البته قاب بیان هست که این صف ها از روش fifo پیروی میکنند
fifo = first in first out


برای ارسال پیام های مناسب به صف های مناسب از قوانینی به نام binding استفاده میکنند این binding قوانینی هست که برای اتصال صف ها به exchange تنطیم میشود
--------------------------------------------------------------------------------------------------
در جریان پیام در RabbitMQ
 تولیدکننده یک پیام را exchange، push می کند. هنگام ایجاد exchange، نوع آن باید مشخص شود.
 این Exchange پیام را دریافت می کند و اکنون مسئول مسیر دهی به پیام است
 بین exchange و صف باید binding تنظیم شود  exchange، براساس ویژگی های پیام ها (message attribute)، آن ها را به صف ها مسیردهی می کند
 یام ها در صف قرار می گیرند تا زمانی که توسط یک consumer، مصرف شوند
 و Consumer، پیام ها را پردازش می کند
--------------------------------------------------------------------------------------------------
routing key = یک ادرس هست که اکسچنچ ها برای تصمیم گیری در مورد نحوه مسردهی پیام از ان استفاده میشود
در exchangeها پیام ها در صف های متفاوتی مسیر دهی میشود
directدرخوست رو از روتینگ کی نگاه میکند و به صف ارسال میکند
fanout کاری با روتینگ کی ندارد درخواست ها رو توی تمامی صف ها کپی میکند
topic یک سری الگویی رو به ان میدهیم که بر اساس ان به صف ها ارسال میکند
header exchange که به صورت کلید و ومقدار به ان مقدار میدهیم
که یکی مطابقت داشت یا همه ان ها مطابقت داشته باشد any,all

--------------------------------------------------------------------------------------------------
برای اتصال به سرور  و کاهش مصرف منابع ان یک کانال ایجاد میکنیم که کانسیومر ها به این کانال ها متصل شده و این کانال ها هم یک اتصالی به سرور دارد
کانسیومر ها اتصالی که به کانال ها دارد رو استفاده میکنند


 برای مطالعه بهتر در این ادرس وجود دارد
 https://sokanacademy.com/blog/%D8%B1%D8%A7%D9%87%D9%86%D9%85%D8%A7%DB%8C-%D8%B3%D8%B1%DB%8C%D8%B9%DB%8C-%D8%A8%D8%B1%D8%A7%DB%8C-%D8%AF%D8%B1%DA%A9-rabbitmq

-------------------------------------------------------------------------------------------------
queue_declare = برای ایجاد یک صف استفاده میشود
basic_publish = ارسال یک پیغام
routing_key اسم اون صفی هست که قرار هست بفرستیم
basic_consume خواندن اطلاعات از صف
on_message_callback به صف ما وصل شد چی کار کند چه چیزی رو نشان دهد
auto_ack خود کانسیوم درخواست ها رو بعد از پردازش ان را حذف میکند
def callback = اون پیغام و اون چیزهایی که که میخواهیم رو نمایش میدهد
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
plugin
یک رابط گرافیکی هست که درون مرورگر میشود ان را نمایش داد و یکسری ویژگی به ان اضافه کرد
rabbitmq-plugins
rabbitmq-admin = برای کار کردن با ادمین هست ولی البته اول درون پلاگین ان را فعال کرد
rabbitmqctl کانکشن ها رو مدیریت میکند

برای فعال سازی پلاگین از دستور زیر استفاده میکینم
sudo rabbitmq-plugins enable plagin_name
برای غیر فعال سازی پلاگین از دستور زیر استفاده میکنیم
sudo rabbitmq-plugins disable rabbitmq_management

E* = خود ربیت ام کیو این پلاگین رو فعال کرده
http://localhost:15672/#/ دسترسی به پلاگین

----------------------------------------------------------------------------------------------------------
rabbitmq-ctl
چند تا سرور فیزیکی رو در کنار هم قرار داده و بگوییم از همدیگر استفاده کن که این clusterنام دارد
هر کدام از این سروها به نرم افزار ما وصل شده نود نام دارد
این rabbitmqctl یک ابزاری برای مدیریت کردن نودهای ربیت ام کیو
sudo rabbitmqctl list_queues = دیدن تمام صف هایی که کانسیوم نشده رو نسان میدهد
rabbitmqctl list_users لیست تمامی یوزرها رو نشان میدهد

---------------------------------------------------------------------------------------------------------------------------------
woking queue
Round-robinکارها رو پخش میکند بین کانسیومر ها
مثلا چند تا صف و چند تا کانسیومر داریم که هر کدام رو به به طور مخشص پخش میکند
durable= وقتی وسط کار سرور کرش کند و برای جلوگیری از حذف شدن این کیوها رو درون هارد اطلاعات رو بنویس تا این اطلاعات کیو ها از بین نرود
برای جلوگیری از حذف مسیج ها و پیغام ها درون کیو ها باید از روش زیر استفاده کنیم
channel.basic_publish(
    exchange='',
    routing_key='working_queue',
    body=message,
    properties=pika.BasicProperties(
        delivery_mode=2,
    ))

درون baic_publish یک فیلدی به نام properties قرار میدهیم و ان را با توجه به راهنمایی ربیت ام کیو مقدار دهی میکنیم
https://www.rabbitmq.com/publishers.html
توی بخش Message Properties هست




کانسیور اطلاعات رو از چنل برمیدارد و ان را پردازش میکند و بعدش به چنل میگوید که این درخواست رو حذف کنید که این حذف درخواست توسط Acknowledgements انجام میشود که این درخواست پردازش شده رو حذف کنند
channel.basic_ack(delivery_tag=method.delivery_tag)اطلاعات رو که بعد از پردازش حذف کند
یک خبری به ربیت ام کیو میدهد که این درخواست پرادزش شده هست و بیا ان را حذف کن
این auto_ack رو بهتر است به صورت دستی استفاده کرد چون وقتی به صورت اتوماتیک باشد بعد از درخواست از کیو به کانسیومر فرستاده شود خوب اگر روی حالت اتوماتیک باشد به صورت خودکار ان را از صف حذف میکند و مشکل جایی پیش میاد که اگر وسط کار سرور به هر دلیلی قطع شود دیگر نه درخواست درون صف وجود دارد و نه درست پردازش شده هست
و به این روش میتوان ان را به صورت دستی تنطیم کرد    channel.basic_ack(delivery_tag=method.delivery_tag)



channel.basic_qos(prefetch_count=1)یکی یکی درخواست ها رو به کانسیومرها میدهد


properties =

Headersاز اون جایی که یک درخواست رو میفرستیم میتوان تعیین کرد که علاوه بر درخواست یک دیکشنری هم فرستاده شود
و از اون طرف درون متود callback میتوان با properties ها به هدر ان دسترسی داشت
که علاوه بر درخواست باید اون properties رو بگیریم

delivery_tag = هر درخواست که میفرستیم و پردازش روی ان انجام میود دارای یک کد شناسایی هست
یک عدد مثبت هست که هر تسکی تمام شود میتوان فهیمد که کدوم ها شناسایی شده اند

sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
این دستور میگوید لیست ها رو نمایش بدهد نام ان ها و پیام های اماده و پیغام های که در حال پراسس هستند رو
نشان بده
routing_key = اون اکسچنچ رو بر اساس روتینگ کی به کیو مورد نظر وصل میکند

-------------------------------------------------------------------------------------------------
fanout
درون این جا routing_key دیگر نداریم
اکسچنج رو ایجاد کرده بعد binding که این binding ها به کیو های مورد نظر وصل شود

exclusive=True = به محض این که کانسیور وصل شد به صف  و اطلاعات رو خواند اون صف حذف میشود و از اول ایجاد شود
exchange_type='fanout' = در این حالت تمامی پیغام ها درون تمامی صف ها میرود
توی fanout نام queue برای ما مهم نیست میسپارین که خود rabbitmq برای ا بسازد
exclusive=True = اصلاعات قبلی رو از صف بگیرد و حذف کند
---------------------------------------------------------------------------------------------------
routing
در این جا یک کانسیومر یک فایل رو دریافت میکند و یک فایل هم لاگ اندازی میکند
----------------------------------------------------------------------------------------------------
topic
در این جا دو جور اطلاعات وجود دارد که یکی از ان ها مهم هست که ان را ذخیره میکنیم و  دیگری مهم نیست و ان را ذخیره نمیکنیم
----------------------------------------------------------------------------------------------------




























